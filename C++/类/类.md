#类&对象
[toc]
##类成员函数

###成员函数的定义方法
1.在类内部进行定义——内联定义。
2.使用**范围解析运算符（::）**进行定义。

##类访问修饰符
关键字 `public`、`private`、`protected` 称为访问修饰符.
每个标记区域在下一个标记区域开始之前或者在遇到类主体结束右括号之前都是有效的。
成员和类的默认访问修饰符是`private`。
1.公有（public）成员
**公有**成员在程序中类的外部是可访问的。您可以不使用**任何成员函数**来设置和获取公有变量的值
2.私有（private）成员
**私有**成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有**类**和***友元**函数可以访问私有成员。**默认情况下，类的所有成员都是私有的**。
3. 保护（protected）成员
**保护**成员变量或函数与私有成员十分相似，但有一点不同，**保护成员在派生类（即子类）中是可访问的。**

```
#include <iostream>
using namespace std;
 
class Box
{
   protected:
      double width;
};
 
class SmallBox:Box // SmallBox 是派生类
{
   public:
      void setSmallWidth( double wid );
      double getSmallWidth( void );
};
 
// 子类的成员函数
double SmallBox::getSmallWidth(void)
{
    return width ;
}
 
void SmallBox::setSmallWidth( double wid )
{
    width = wid;
}
 
// 程序的主函数
int main( )
{
   SmallBox box;
 
   // 使用成员函数设置宽度
   box.setSmallWidth(5.0);
   cout << "Width of box : "<< box.getSmallWidth() << endl;
 
   return 0;
}
```

###继承的访问属性修饰符
类有`public`, `protected`,` private`三种继承方式，它们相应地改变了基类成员的访问属性。

1. public 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private
2. protected 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private
3. private 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private

但无论哪种继承方式，上面两点都没有改变：
1. private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；
2. protected 成员可以被派生类访问。

##类的构造函数
类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。

构造函数的名称与类的名称是完全相同的，**并且不会返回任何类型，也不会返回 void**。构造函数**可用于为某些成员变量设置初始值**。

默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值。

###使用初始化列表来初始化字段
>https://blog.csdn.net/sinat_20265495/article/details/53670644

使用初始化列表有两个原因：
原因1.必须这样做：
《C++ Primer》中提到在以下三种情况下需要使用初始化成员列表：
* 情况一、需要初始化的数据成员是对象的情况(这里包含了继承情况下，通过显示调用父类的构造函数对父类数据成员进行初始化)；
* 情况二、需要初始化const修饰的类成员或初始化引用成员数据；
* 情况三、子类初始化父类的私有成员；
原因2.效率要求这样做：
类对象的构造顺序显示，进入构造函数体后，进行的是计算，是对成员变量的赋值操作，显然，赋值和初始化是不同的，这样就体现出了效率差异，如果不用成员初始化类表，那么类对自己的类成员分别进行的是一次隐式的默认构造函数的调用，和一次赋值操作符的调用，如果是类对象，这样做效率就得不到保障。

注意：构造函数需要初始化的数据成员，不论是否显示的出现在构造函数的成员初始化列表中，都会在该处完成初始化，并且初始化的顺序和其在类中声明时的顺序是一致的，与列表的先后顺序无关，所以要特别注意，保证两者顺序一致才能真正保证其效率和准确性。

###类的析构函数
类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。

析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。


##拷贝构造函数(复制构造函数)
C++ primer p406 ：复制构造函数是一种特殊的构造函数，具有单个形参，该形参（常用const修饰）是对该类类型的引用。当定义一个新对象并用一个同类型的对象对它进行初始化时，将显示使用复制构造函数。当该类型的对象传递给函数或从函数返回该类型的对象时，将隐式调用复制构造函数。


###什么情况使用复制构造函数
以下情况都会调用拷贝构造函数：
1. **一个对象以值传递的方式传入函数体**：将主调函数实参赋值给被调用函数的形参的过程是由拷贝构造函数完成的。
2. **一个对象以值传递的方式从函数返回**：函数返回之前，会创建一个临时对象，将局部对象赋值给这个临时对象，这个过程也是由拷贝构造函数实现的。
3. **一个对象需要通过另外一个对象进行初始化**

##友元
###友元函数
在当前类以外定义的、不属于当前类的函数也可以在类中声明，但要在前面加 friend 关键字，这样就构成了友元函数。友元函数可以是不属于任何类的非成员函数，也可以是其他类的成员函数。

友元函数可以访问当前类中的所有成员，包括 public、protected、private 属性的。
1. 可将非成员函数声明为友元函数。
2. 也可将其他类的成员函数声明为友元函数。

###友元类
不仅可以将一个函数声明为一个类的“朋友”，还可以将整个类声明为另一个类的“朋友”，这就是友元类。友元类中的所有成员函数都是另外一个类的友元函数。

例如将类 B 声明为类 A 的友元类，那么类 B 中的所有成员函数都是类 A 的友元函数，可以访问类 A 的所有成员，包括 public、protected、private 属性的。

关于友元类，有两点需要说明：
* 友元的关系是单向的而不是双向的。如果声明了类 B 是类 A 的友元类，不等于类 A 是类 B 的友元类，类 A 中的成员函数不能访问类 B 中的 private 成员。
* 友元的关系不能传递。如果类 B 是类 A 的友元类，类 C 是类 B 的友元类，不等于类 C 是类 A 的友元类。

**注意：**除非有必要，一般不建议把整个类声明为友元类，而只将某些成员函数声明为友元函数，这样更安全一些。

**友元的作用是什么？**
友元提供了在不同类的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制。通过友元，一个普通函数或另一个类中的成员函数可以访问类中的私有成员和保护成员。C＋＋中的友元为封装隐藏这堵不透明的墙开了一个小孔，外界可以通过这个小孔窥视内部的秘密。
友元的正确使用能提高程序的运行效率，但破坏了类的封装性和数据的隐蔽性，导致程序可维护性变差，因此一定要谨慎使用。
作为一种编程技术手段，友元为程序员提供了一种面向对象程序和面向过程程序相互衔接的接口。从根本上说面向对象的分析与设计方法并不能彻底解决现实世界中的一切需求。许多按照对象化设计的软件系统常常保留一些供早期程序访问的接口，来扩大自身功能，提高自己产品的竞争能力。友元较为实际的应用是运算符重载，从而提高软件系统的灵活性。

##内联函数
###背景
函数的调用需要建立内存的堆栈，进行参数传递，并产生程序执行转移，这些工作需要一定的时间开销，有些函数使用的频率高，但是代码却很短，比如获取较大的值或者较小的值。

对于上述场景，c和c++都提供了相应的优化方式：
* c:使用宏定义
* c++:使用宏定义，或则使用**内联函数**。

c++提供了inline函数（内联函数），减少函数调用的成本。编译器看到inline后，会为该函数创建一段代码，以便以后在后面每次碰到该函数掉调用都用一段带代码替换

###内联函数特点
* 1.内联函数可以在一开始仅声明一次
* 2.内联函数必须在调用之前被声明或定义，因为内联函数的代码必须在被替换之前生成被替换的代码。
* 3.内联函数中，不能包含复杂的结构控制语句，比如switch或者while，如果内联函数有这些语句，则编译将该函数视同普通函数那样调用代码
* 4.递归函数不能用做内联函数
* 5.将大多数inline函数限制在小型被频繁使用的函数上（内联函数只适合1-5行的小函数，对于较大的函数，函数调用和返回的开销相对来说微不足道，所以也没必要用内联函数实现）

###内联函数和宏定义的区别
宏只是告诉编译器简单的替换代码，不检查参数类型。但是内联函数拥有函数的所有功能，不仅能进行常规的参数检查，还能得到所有可预见的状态。

###什么时候使用内联函数
如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间占比很小。若代码执行时间很短，则内联函数就可以节省函数调用的时间。

##this指针
在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。

友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。

##指向类的指针
指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。

##类的静态成员
###类的静态变量
我们可以使用 static 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。

静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。**我们不能把静态成员的初始化放置在类的定义中**，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化。


###类的静态函数
如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。**静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问**。

静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。（因为类的非静态成员需要对象存在时才有效，才可被访问）

静态成员函数有一个类范围，他们不能访问类的 this 指针。您可以使用静态成员函数来判断类的某些对象是否已被创建。

####静态成员函数与普通成员函数的区别：
* 静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。
* 普通成员函数有 this 指针，可以访问类中的任意成员；

###类的静态成员的作用
**从OOA/OOD的角度考虑，一切不需要实例化就可以有确定行为方式的函数都应该设计成静态的。**
> OOA,Object-Oriented Analysis:面向对象分析法
> OOD,Object-oriented Design:面向对象设计

类的静态成员有如下几个有点：
1. **可以封装某些算法**，比如数学函数，如ln，sin，tan等等，这些函数本就没必要属于任何一个对象，所以从类上调用感觉更好，比如定义一个数学函数类Math，调用Math::sin(3.14);如果非要用非静态函数，那就必须：Math  math;    math.sin(3.14);
2. 从变量创建上来讲：
* 静态全局变量，在其他文件中可以定义相同的名字而不会发生冲突；
* 静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到一下次的调用，直到下次赋值；
* 静态函数只能在声明它的文件当中可见，不能被其他文件使用，在其他文件中可以定义相同名字的函数，不会发生冲突。

