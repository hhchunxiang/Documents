#C/C++面试题
[toc]
##基础概念
###定义和声明
####变量的定义和声明有什么区别
* 声明，用于向编译器表明变量或函数的类型（或返回值类型）和标识符，声明告诉了编译器“某个变量或者函数可以在某处找到”。声明不需要创建内存空间。
* 定义，为变量或函数创建一片内存空间，并对变量或函数进行声明。

声明和定义的本质区别：定义需要创建内存空间，声明不需要。

一个变量或函数可以进行多次声明，但一个变量或函数只能被定义一次。

常见的基本类型变量或函数的声明形式：
* 定义过程中包含的声明：
* 使用extern关键字声明外部变量

基本类型变量或函数的声明和定义是同时产生的。但对于对象来说，声明和定义是分开的。如，有类A，则：
```
A a;//第一句
a = New A();//第二句
```
其中，第一句只是个声明，告诉编译器a是类A的一个实列化对象，但不分配内存。第二句才为对象a分配了内存空间，并对其进行了初始化；

####sizeof和strlen的区别
* sizeof是一个操作符，strlen是库函数。
* sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为‘\0‘的字符串作参数。
* 编译器在编译时就计算出了sizeof的结果。而strlen函数必须在运行时才能计算出来。并且sizeof计算的是数据类型占内存的大小，而strlen计算的是字符串实际的长度。
* 数组做sizeof的参数不退化，传递给strlen就退化为指针了。

####数组名称退化为指针
C语言中，数组名称作为参数传递给函数时，会退化为指针。

怎样防止数组名称退化为指针？
使用数组的引用。
```
#include<stdio.h>
#include<string.h>
#include<stdlib.h>

int arry[10] = {10,11, 12, 13, 14, 15, 16, 17, 18, 19};

void test1(int *a) {
	printf("test1:%d\n", sizeof(a));

	return;
}

void test2(int (&a)[10]) {
	printf("test2:%d\n", sizeof(a));

	return;
}

int main(void) {

	test1(arry);//输出4

	test2(arry);//输出40

	system("pause");
	return 0;
}
```

##变量



##函数
##指针
###简述指针常量与常量指针区别
####常量指针（被指向的对象是常量）
**定义：**
又叫常指针，可以理解为**常量的指针**，指向的是一个常量；
**关键点：**
* 常量指针指向的对象不能通过这个指针来修改，可是仍然可以通过原来的声明修改。
* 常量指针可以被赋值为变量的地址，之所以叫常量指针，是限制了通过这个指针修改变量的值。
* 指针还可以指向别处，因为指针本身只是个变量，可以指向任意地址；
**代码形式：**
```
const int *p;
int const *p;
```

####指针常量(指针本身是常量)
**定义：**
指针本身是一个常量，在定义的时候就需要对其进行初始化，并且之后不允许再次改动其指向。
**关键点：**
* 它是个常量！
* 定义的时候必须对其进行初始化，之后都不允许其再指向其他内存地址；
**代码形式：**
```
int* const p;
```

####指向常量的常指针
代码形式：
```
const int * const p;
int const * const p;
```

####如何区分常量指针和指针常量？
一种方式是看 * 和 const 的排列顺序，比如
```
int const* p;   //const * 即常量指针
const int* p;   //const * 即常量指针
int* const p;   //* const 即指针常量
```
还一种方式是看const离谁近，即从右往左看，比如
```
int const* p;   //const修饰的是*p，即*p的内容不可通过p改变，但p不是const，p可以修改，*p不可修改；
const int* p;   //同上
int* const p;   //const修饰的是p，p是指针，p指向的地址不能修改，p不能修改，但*p可以修改；
```

###一个指针可以是volatile吗？
可以，因为指针和普通变量一样，有时也有变化程序的不可控性。常见例：子中断服务子程序修改一个指向一个buffer的指针时，必须用volatile来修饰这个指针。

###a和&a的区别
1. 当a是普通变量时：
a：表述普通变a的值
&a：表述保存变量a值的地址值
2. 当a是一维数组时：
a：可以理解为一个指针，表示数组第一个元素的地址
>但我们不能认为a就是一个指针，它依旧是一个数组的标识符，sizeof(a)说明了这点，它会计算出数组占用的存储空间。
&a：这是一个数组指针，表示一个指向数组的指针。假如数组有n个元素，则&a+1相当于a+n，即指向数组最后一个元素之后的一个存储空间（此时发生了数组越界）。
3. 当a是二维数组时
a：可以理解为一个指针，指向二维数组的第一个元素；
>但我们不能认为a就是一个指针，它依旧是一个数组的标识符，sizeof(a)说明了这点，它会计算出数组占用的存储空间。
&a:表示的是一个指向二维数组的指针，&a+1，表示指向数组最后一个元素后面的一个存储空间。

##内存
###C的内存划分
1. 栈(Stack)
2. 堆(Heap)
3. 全局区/静态区(Global/Static Area)：
4. 常量存储区：用于存放字符串常量，程序结束时释放。
5. 程序代码区：存放二进制代码

##数据结构
###链表与数组的区别
* 存储形式：数组是一种线性存储结构，各元素的存储空间是连续的；链表是一种非线性存储结构，各元素的存储空间是可不连续的的。
* 数据查找：数组的线性查找速度块，查找操作直接使用地址偏移即可；链表需要按照按顺序检索节点，效率低。
* 数据插入/删除：链表可以快速插入和删除节点，而数组可能需要大量移动数据。
* 越界问题：数组存在越界问题，链表没有。

>说明:使用链表还是数组，要根据实际需要进行选择。
>* 链表的优点是便于插入/删除，数组则是便于查询
>* 有些场景链表可以实现内存的节约
>* 有些场景可以考虑"数组+链表"的数据结构，结合二者的优点。

##文件
##效率
##算法
##综合